<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Cube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="info">
        Left click + drag: Rotate<br>
        Right click + drag: Move
    </div>
    <canvas id="webgl-canvas" width="800" height="600"></canvas>

    <script>
        // Vertex shader source
        const vertexShaderSource = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            
            uniform mat4 u_modelViewMatrix;
            uniform mat4 u_projectionMatrix;
            
            varying vec4 v_color;
            
            void main() {
                gl_Position = u_projectionMatrix * u_modelViewMatrix * a_position;
                v_color = a_color;
            }
        `;

        // Fragment shader source
        const fragmentShaderSource = `
            precision mediump float;
            
            varying vec4 v_color;
            
            void main() {
                gl_FragColor = v_color;
            }
        `;

        // Matrix utilities
        function createMatrix4() {
            return new Float32Array(16);
        }

        function identity(matrix) {
            matrix[0] = 1; matrix[1] = 0; matrix[2] = 0; matrix[3] = 0;
            matrix[4] = 0; matrix[5] = 1; matrix[6] = 0; matrix[7] = 0;
            matrix[8] = 0; matrix[9] = 0; matrix[10] = 1; matrix[11] = 0;
            matrix[12] = 0; matrix[13] = 0; matrix[14] = 0; matrix[15] = 1;
        }

        function perspective(matrix, fovy, aspect, near, far) {
            const f = Math.tan(Math.PI * 0.5 - 0.5 * fovy);
            const rangeInv = 1.0 / (near - far);

            matrix[0] = f / aspect;
            matrix[1] = 0;
            matrix[2] = 0;
            matrix[3] = 0;
            matrix[4] = 0;
            matrix[5] = f;
            matrix[6] = 0;
            matrix[7] = 0;
            matrix[8] = 0;
            matrix[9] = 0;
            matrix[10] = (near + far) * rangeInv;
            matrix[11] = -1;
            matrix[12] = 0;
            matrix[13] = 0;
            matrix[14] = near * far * rangeInv * 2;
            matrix[15] = 0;
        }

        function translate(matrix, x, y, z) {
            matrix[12] += matrix[0] * x + matrix[4] * y + matrix[8] * z;
            matrix[13] += matrix[1] * x + matrix[5] * y + matrix[9] * z;
            matrix[14] += matrix[2] * x + matrix[6] * y + matrix[10] * z;
            matrix[15] += matrix[3] * x + matrix[7] * y + matrix[11] * z;
        }

        function rotateX(matrix, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const a10 = matrix[4], a11 = matrix[5], a12 = matrix[6], a13 = matrix[7];
            const a20 = matrix[8], a21 = matrix[9], a22 = matrix[10], a23 = matrix[11];

            matrix[4] = a10 * c + a20 * s;
            matrix[5] = a11 * c + a21 * s;
            matrix[6] = a12 * c + a22 * s;
            matrix[7] = a13 * c + a23 * s;
            matrix[8] = a20 * c - a10 * s;
            matrix[9] = a21 * c - a11 * s;
            matrix[10] = a22 * c - a12 * s;
            matrix[11] = a23 * c - a13 * s;
        }

        function rotateY(matrix, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const a00 = matrix[0], a01 = matrix[1], a02 = matrix[2], a03 = matrix[3];
            const a20 = matrix[8], a21 = matrix[9], a22 = matrix[10], a23 = matrix[11];

            matrix[0] = a00 * c - a20 * s;
            matrix[1] = a01 * c - a21 * s;
            matrix[2] = a02 * c - a22 * s;
            matrix[3] = a03 * c - a23 * s;
            matrix[8] = a00 * s + a20 * c;
            matrix[9] = a01 * s + a21 * c;
            matrix[10] = a02 * s + a22 * c;
            matrix[11] = a03 * s + a23 * c;
        }

        // Shader compilation utilities
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Main application
        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Create shaders and program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Get attribute and uniform locations
        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const colorAttributeLocation = gl.getAttribLocation(program, 'a_color');
        const modelViewMatrixLocation = gl.getUniformLocation(program, 'u_modelViewMatrix');
        const projectionMatrixLocation = gl.getUniformLocation(program, 'u_projectionMatrix');

        // Cube vertices (positions)
        const positions = new Float32Array([
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ]);

        // Cube colors (one color per face)
        const colors = new Float32Array([
            // Front face - Red
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,

            // Back face - Green
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,

            // Top face - Blue
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,

            // Bottom face - Yellow
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,

            // Right face - Purple
            1.0, 0.0, 1.0, 1.0,
            1.0, 0.0, 1.0, 1.0,
            1.0, 0.0, 1.0, 1.0,
            1.0, 0.0, 1.0, 1.0,

            // Left face - Cyan
            0.0, 1.0, 1.0, 1.0,
            0.0, 1.0, 1.0, 1.0,
            0.0, 1.0, 1.0, 1.0,
            0.0, 1.0, 1.0, 1.0
        ]);

        // Cube indices
        const indices = new Uint16Array([
            0,  1,  2,      0,  2,  3,    // front
            4,  5,  6,      4,  6,  7,    // back
            8,  9,  10,     8,  10, 11,   // top
            12, 13, 14,     12, 14, 15,   // bottom
            16, 17, 18,     16, 18, 19,   // right
            20, 21, 22,     20, 22, 23    // left
        ]);

        // Create buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        // Transformation state
        let rotationX = 0;
        let rotationY = 0;
        let translationX = 0;
        let translationY = 0;
        let translationZ = -6;

        // Mouse state
        let isMouseDown = false;
        let isRightMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Mouse event handlers
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isMouseDown = true;
            isRightMouseDown = e.button === 2;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            isMouseDown = false;
            isRightMouseDown = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isMouseDown) return;
            
            e.preventDefault();
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            if (isRightMouseDown) {
                // Right mouse button - translate
                translationX += deltaX * 0.01;
                translationY -= deltaY * 0.01;
            } else {
                // Left mouse button - rotate
                rotationY += deltaX * 0.01;
                rotationX += deltaY * 0.01;
            }
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Matrices
        const modelViewMatrix = createMatrix4();
        const projectionMatrix = createMatrix4();

        // Set up projection matrix
        perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);

        function render() {
            // Clear the canvas
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Enable depth testing
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            // Use our shader program
            gl.useProgram(program);

            // Set up model-view matrix
            identity(modelViewMatrix);
            translate(modelViewMatrix, translationX, translationY, translationZ);
            rotateX(modelViewMatrix, rotationX);
            rotateY(modelViewMatrix, rotationY);

            // Set uniforms
            gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);
            gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

            // Bind color buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(colorAttributeLocation);
            gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);

            // Bind index buffer and draw
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            // Request next frame
            requestAnimationFrame(render);
        }

        // Start rendering
        render();
    </script>
</body>
</html>