<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Visualization Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #f5f5f5;
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }

        .main-view {
            flex: 1;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            font-size: 13px;
            color: #666;
            margin-bottom: 5px;
        }

        .select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            font-size: 13px;
        }

        .slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
        }

        .slider-value {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        canvas {
            border: 1px solid #ccc;
            background: white;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 15px;
            font-size: 12px;
            color: #666;
            min-width: 200px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .info-label {
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="control-group">
            <div class="control-title">Mesh Type</div>
            <div class="control-item">
                <label class="control-label">Element Type</label>
                <select class="select" id="meshType">
                    <option value="hexa">Hexahedral (Hexa)</option>
                    <option value="tetra">Tetrahedral (Tetra)</option>
                    <option value="poly">Polyhedral (Poly)</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <div class="control-title">Mesh Parameters</div>
            <div class="control-item">
                <label class="control-label">Mesh Density</label>
                <input type="range" class="slider" id="meshDensity" min="1" max="10" value="3">
                <div class="slider-value">Divisions: <span id="densityValue">3</span></div>
            </div>
            <div class="control-item">
                <label class="control-label">Size</label>
                <input type="range" class="slider" id="meshSize" min="1" max="4" step="0.1" value="2">
                <div class="slider-value">Size: <span id="sizeValue">2.0</span></div>
            </div>
        </div>

        <div class="control-group">
            <div class="control-title">Display</div>
            <div class="control-item">
                <label class="control-label">Transparency</label>
                <input type="range" class="slider" id="transparency" min="0" max="90" step="5" value="15">
                <div class="slider-value">Opacity: <span id="transparencyValue">85</span>%</div>
            </div>
        </div>

    </div>

    <div class="main-view">
        <div class="info-panel">
            <div class="info-row">
                <span class="info-label">Elements:</span>
                <span id="elementCount">27</span>
            </div>
            <div class="info-row">
                <span class="info-label">Nodes:</span>
                <span id="nodeCount">64</span>
            </div>
            <div class="info-row">
                <span class="info-label">Faces:</span>
                <span id="faceCount">54</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube, wireframe;
        let meshDensity = 3;
        let meshSize = 2.0;
        let meshType = 'hexa';

        // Mouse interaction
        let isLeftMouseDown = false;
        let isRightMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let positionVelocity = { x: 0, y: 0 };
        const damping = 0.95;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Orthogonal Camera
            const frustumSize = 5;
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            camera.position.set(4, 4, 4);
            camera.lookAt(0, 0, 0);

            // Premium renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            const container = document.querySelector('.main-view');
            const width = container.clientWidth * 0.8;
            const height = container.clientHeight * 0.8;
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Enhanced lighting for premium look
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
            
            // Additional fill light
            const fillLight = new THREE.DirectionalLight(0x6366f1, 0.3);
            fillLight.position.set(-3, -3, 2);
            scene.add(fillLight);

            // Create initial mesh
            createMesh();

            // Setup controls
            setupControls();

            // Animation loop
            animate();
        }

        function createTetrahedralMesh() {
            // Create a tetrahedral mesh by arranging tetrahedra in a grid
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            const step = meshSize / meshDensity;
            let vertexIndex = 0;
            
            // Create tetrahedral elements in a grid
            for (let x = 0; x < meshDensity; x++) {
                for (let y = 0; y < meshDensity; y++) {
                    for (let z = 0; z < meshDensity; z++) {
                        const baseX = (x - meshDensity/2 + 0.5) * step;
                        const baseY = (y - meshDensity/2 + 0.5) * step;
                        const baseZ = (z - meshDensity/2 + 0.5) * step;
                        
                        // Create a tetrahedron at this position
                        const tetraVertices = [
                            [baseX, baseY + step*0.3, baseZ],           // top
                            [baseX - step*0.3, baseY - step*0.2, baseZ + step*0.3],  // front left
                            [baseX + step*0.3, baseY - step*0.2, baseZ + step*0.3],  // front right
                            [baseX, baseY - step*0.2, baseZ - step*0.3]   // back
                        ];
                        
                        // Add vertices
                        tetraVertices.forEach(v => {
                            vertices.push(v[0], v[1], v[2]);
                        });
                        
                        // Add faces (4 triangular faces for tetrahedron)
                        const base = vertexIndex;
                        indices.push(
                            base, base + 1, base + 2,    // bottom face
                            base, base + 2, base + 3,    // right face
                            base, base + 3, base + 1,    // left face
                            base + 1, base + 3, base + 2 // back face
                        );
                        
                        vertexIndex += 4;
                    }
                }
            }
            
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }

        function createMesh() {
            // Remove existing mesh
            if (cube) scene.remove(cube);
            if (wireframe) scene.remove(wireframe);

            // Create geometry based on mesh type
            let geometry;
            if (meshType === 'tetra') {
                geometry = createTetrahedralMesh();
            } else {
                // Default to box geometry for hexa and poly
                geometry = new THREE.BoxGeometry(meshSize, meshSize, meshSize, meshDensity, meshDensity, meshDensity);
            }

            // Premium cube material with better lighting
            const cubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x6b7280,
                metalness: 0.3,
                roughness: 0.4,
                clearcoat: 0.3,
                clearcoatRoughness: 0.2,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide
            });

            // Premium black wireframe material
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x1f2937,
                wireframe: true,
                linewidth: 2,
                transparent: true,
                opacity: 0.9
            });

            // Create meshes with shadows
            cube = new THREE.Mesh(geometry, cubeMaterial);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            wireframe = new THREE.Mesh(geometry.clone(), wireframeMaterial);
            wireframe.castShadow = true;

            scene.add(cube);
            scene.add(wireframe);

            // Update info
            updateInfo();
        }

        function updateInfo() {
            const elements = meshDensity * meshDensity * meshDensity;
            
            let nodes, faces;
            if (meshType === 'tetra') {
                // For tetrahedral mesh, each element has 4 nodes and 4 faces
                nodes = elements * 4; // Each tetrahedron has 4 vertices
                faces = elements * 4; // Each tetrahedron has 4 triangular faces
            } else if (meshType === 'hexa') {
                // For hexahedral (cube) mesh
                nodes = (meshDensity + 1) * (meshDensity + 1) * (meshDensity + 1);
                faces = elements * 6; // Each hex has 6 faces
            } else { // poly
                nodes = (meshDensity + 1) * (meshDensity + 1) * (meshDensity + 1);
                faces = elements * Math.floor(Math.random() * 6) + 4; // Variable faces for poly
            }

            document.getElementById('elementCount').textContent = elements;
            document.getElementById('nodeCount').textContent = nodes;
            document.getElementById('faceCount').textContent = faces;
        }

        function setupControls() {
            // Mesh type selector
            document.getElementById('meshType').addEventListener('change', (e) => {
                meshType = e.target.value;
                updateInfo();
            });

            // Mesh density slider
            document.getElementById('meshDensity').addEventListener('input', (e) => {
                meshDensity = parseInt(e.target.value);
                document.getElementById('densityValue').textContent = meshDensity;
                createMesh();
            });

            // Mesh size slider
            document.getElementById('meshSize').addEventListener('input', (e) => {
                meshSize = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = meshSize.toFixed(1);
                createMesh();
            });

            // Transparency slider
            document.getElementById('transparency').addEventListener('input', (e) => {
                const transparencyPercent = parseInt(e.target.value);
                const opacity = (100 - transparencyPercent) / 100;
                document.getElementById('transparencyValue').textContent = (100 - transparencyPercent);
                
                // Update cube opacity
                if (cube) {
                    cube.material.opacity = opacity;
                }
            });

            // Mouse controls
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            canvas.addEventListener('wheel', onWheel);
        }

        function onMouseDown(event) {
            if (event.button === 0) {
                isLeftMouseDown = true;
            } else if (event.button === 2) {
                isRightMouseDown = true;
            }
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseMove(event) {
            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            if (isLeftMouseDown) {
                // Rotate
                rotationVelocity.x = deltaMove.y * 0.01;
                rotationVelocity.y = deltaMove.x * 0.01;
                
                cube.rotation.x += deltaMove.y * 0.01;
                cube.rotation.y += deltaMove.x * 0.01;
                wireframe.rotation.copy(cube.rotation);
            }

            if (isRightMouseDown) {
                // Move
                positionVelocity.x = deltaMove.x * 0.001;
                positionVelocity.y = -deltaMove.y * 0.001;
                
                cube.position.x += deltaMove.x * 0.01;
                cube.position.y -= deltaMove.y * 0.01;
                wireframe.position.copy(cube.position);
            }

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp(event) {
            isLeftMouseDown = false;
            isRightMouseDown = false;
        }

        function onWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.1;
            const frustumSize = Math.max(2, Math.min(10, camera.right * 2 + event.deltaY * zoomSpeed * 0.01));
            const aspect = window.innerWidth / window.innerHeight;
            
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Apply inertia
            if (!isLeftMouseDown && (Math.abs(rotationVelocity.x) > 0.001 || Math.abs(rotationVelocity.y) > 0.001)) {
                cube.rotation.x += rotationVelocity.x;
                cube.rotation.y += rotationVelocity.y;
                wireframe.rotation.copy(cube.rotation);
                
                rotationVelocity.x *= damping;
                rotationVelocity.y *= damping;
            }

            if (!isRightMouseDown && (Math.abs(positionVelocity.x) > 0.001 || Math.abs(positionVelocity.y) > 0.001)) {
                cube.position.x += positionVelocity.x;
                cube.position.y += positionVelocity.y;
                wireframe.position.copy(cube.position);
                
                positionVelocity.x *= damping;
                positionVelocity.y *= damping;
            }

            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>
</body>
</html>
