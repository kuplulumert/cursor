<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Visualization Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #f5f5f5;
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }

        .main-view {
            flex: 1;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            font-size: 13px;
            color: #666;
            margin-bottom: 5px;
        }

        .select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            font-size: 13px;
        }

        .slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
        }

        .slider-value {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        canvas {
            border: 1px solid #ccc;
            background: white;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 15px;
            font-size: 12px;
            color: #666;
            min-width: 200px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .info-label {
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="control-group">
            <div class="control-title">Mesh Type</div>
            <div class="control-item">
                <label class="control-label">Element Type</label>
                <select class="select" id="meshType">
                    <option value="hexa">Hexahedral (Hexa)</option>
                    <option value="tetra">Tetrahedral (Tetra)</option>
                    <option value="poly">Polyhedral (Poly)</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <div class="control-title">Mesh Parameters</div>
            <div class="control-item">
                <label class="control-label">Mesh Density</label>
                <input type="range" class="slider" id="meshDensity" min="1" max="10" value="3">
                <div class="slider-value">Divisions: <span id="densityValue">3</span></div>
            </div>
            <div class="control-item">
                <label class="control-label">Size</label>
                <input type="range" class="slider" id="meshSize" min="1" max="4" step="0.1" value="2">
                <div class="slider-value">Size: <span id="sizeValue">2.0</span></div>
            </div>
        </div>


    </div>

    <div class="main-view">
        <div class="info-panel">
            <div class="info-row">
                <span class="info-label">Elements:</span>
                <span id="elementCount">27</span>
            </div>
            <div class="info-row">
                <span class="info-label">Nodes:</span>
                <span id="nodeCount">64</span>
            </div>
            <div class="info-row">
                <span class="info-label">Faces:</span>
                <span id="faceCount">54</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube, wireframe;
        let meshDensity = 3;
        let meshSize = 2.0;
        let meshType = 'hexa';

        // Mouse interaction
        let isLeftMouseDown = false;
        let isRightMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let positionVelocity = { x: 0, y: 0 };
        const damping = 0.95;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Orthogonal Camera
            const frustumSize = 5;
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            camera.position.set(4, 4, 4);
            camera.lookAt(0, 0, 0);

            // Premium renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            const container = document.querySelector('.main-view');
            const width = container.clientWidth * 0.8;
            const height = container.clientHeight * 0.8;
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Enhanced lighting for premium look
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
            
            // Additional fill light
            const fillLight = new THREE.DirectionalLight(0x6366f1, 0.3);
            fillLight.position.set(-3, -3, 2);
            scene.add(fillLight);

            // Create initial mesh
            createMesh();

            // Setup controls
            setupControls();

            // Animation loop
            animate();
        }

        function createMesh() {
            // Remove existing mesh
            if (cube) scene.remove(cube);
            if (wireframe) scene.remove(wireframe);

            // Create geometry
            const geometry = new THREE.BoxGeometry(meshSize, meshSize, meshSize, meshDensity, meshDensity, meshDensity);

            // Premium cube material with better lighting
            const cubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x6b7280,
                metalness: 0.3,
                roughness: 0.4,
                clearcoat: 0.3,
                clearcoatRoughness: 0.2,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide
            });

            // Premium black wireframe material
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x1f2937,
                wireframe: true,
                linewidth: 2,
                transparent: true,
                opacity: 0.9
            });

            // Create meshes with shadows
            cube = new THREE.Mesh(geometry, cubeMaterial);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            wireframe = new THREE.Mesh(geometry.clone(), wireframeMaterial);
            wireframe.castShadow = true;

            scene.add(cube);
            scene.add(wireframe);

            // Update info
            updateInfo();
        }

        function updateInfo() {
            const elements = meshDensity * meshDensity * meshDensity;
            const nodes = (meshDensity + 1) * (meshDensity + 1) * (meshDensity + 1);
            
            let faces;
            if (meshType === 'hexa') {
                faces = elements * 6; // Each hex has 6 faces
            } else if (meshType === 'tetra') {
                faces = elements * 4; // Each tetrahedron has 4 faces
            } else { // poly
                faces = elements * Math.floor(Math.random() * 6) + 4; // Variable faces for poly
            }

            document.getElementById('elementCount').textContent = elements;
            document.getElementById('nodeCount').textContent = nodes;
            document.getElementById('faceCount').textContent = faces;
        }

        function setupControls() {
            // Mesh type selector
            document.getElementById('meshType').addEventListener('change', (e) => {
                meshType = e.target.value;
                updateInfo();
            });

            // Mesh density slider
            document.getElementById('meshDensity').addEventListener('input', (e) => {
                meshDensity = parseInt(e.target.value);
                document.getElementById('densityValue').textContent = meshDensity;
                createMesh();
            });

            // Mesh size slider
            document.getElementById('meshSize').addEventListener('input', (e) => {
                meshSize = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = meshSize.toFixed(1);
                createMesh();
            });



            // Mouse controls
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            canvas.addEventListener('wheel', onWheel);
        }

        function onMouseDown(event) {
            if (event.button === 0) {
                isLeftMouseDown = true;
            } else if (event.button === 2) {
                isRightMouseDown = true;
            }
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseMove(event) {
            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            if (isLeftMouseDown) {
                // Rotate
                rotationVelocity.x = deltaMove.y * 0.01;
                rotationVelocity.y = deltaMove.x * 0.01;
                
                cube.rotation.x += deltaMove.y * 0.01;
                cube.rotation.y += deltaMove.x * 0.01;
                wireframe.rotation.copy(cube.rotation);
            }

            if (isRightMouseDown) {
                // Move
                positionVelocity.x = deltaMove.x * 0.001;
                positionVelocity.y = -deltaMove.y * 0.001;
                
                cube.position.x += deltaMove.x * 0.01;
                cube.position.y -= deltaMove.y * 0.01;
                wireframe.position.copy(cube.position);
            }

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp(event) {
            isLeftMouseDown = false;
            isRightMouseDown = false;
        }

        function onWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.1;
            const frustumSize = Math.max(2, Math.min(10, camera.right * 2 + event.deltaY * zoomSpeed * 0.01));
            const aspect = window.innerWidth / window.innerHeight;
            
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Apply inertia
            if (!isLeftMouseDown && (Math.abs(rotationVelocity.x) > 0.001 || Math.abs(rotationVelocity.y) > 0.001)) {
                cube.rotation.x += rotationVelocity.x;
                cube.rotation.y += rotationVelocity.y;
                wireframe.rotation.copy(cube.rotation);
                
                rotationVelocity.x *= damping;
                rotationVelocity.y *= damping;
            }

            if (!isRightMouseDown && (Math.abs(positionVelocity.x) > 0.001 || Math.abs(positionVelocity.y) > 0.001)) {
                cube.position.x += positionVelocity.x;
                cube.position.y += positionVelocity.y;
                wireframe.position.copy(cube.position);
                
                positionVelocity.x *= damping;
                positionVelocity.y *= damping;
            }

            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>
</body>
</html>
